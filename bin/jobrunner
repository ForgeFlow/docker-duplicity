#!/usr/bin/env python
"""Run all commands extracted from environment variables when they should."""

from __future__ import unicode_literals

import logging
import re
import smtplib
import requests
import sys
from datetime import datetime
from email.mime.text import MIMEText
from email.utils import formatdate
from os import environ, path
from socket import getfqdn
from string import Template
from subprocess import STDOUT, CalledProcessError, check_output

logging.basicConfig(level=logging.INFO)
logging.root.name = "jobrunner"


# Get expected periodicity from this script's placement
periodicity = path.basename(path.dirname(path.abspath(__file__)))
logging.info("%s UTC - Running %s jobs", datetime.utcnow(), periodicity)

# Get email settings
smtp_host = environ.get("SMTP_HOST")
smtp_port = environ.get("SMTP_PORT")
smtp_user = environ.get("SMTP_USER")
smtp_pass = environ.get("SMTP_PASS", "")
smtp_tls = environ.get("SMTP_TLS", "").lower() in {"1", "true"}
from_ = environ.get("EMAIL_FROM")
to = environ.get("EMAIL_TO")
subject = environ.get("EMAIL_SUBJECT")

# Get REST settings
rest_endpoint = environ.get("REST_ENDPOINT")
rest_json = environ.get("REST_JSON")
rest_always = environ.get("REST_ALWAYS").lower() in {"1", "true"}

# Get the commands we need to run
to_run = {}
for key, when in environ.items():
    match = re.match(r"^JOB_(\d+)_WHEN$", key)
    if match and periodicity in when.split():
        njob = int(match.group(1))
        to_run[njob] = environ["JOB_{}_WHAT".format(njob)]


if not to_run:
    logging.info("Nothing to do")
    sys.exit()

# Run commands in order
message = []
failed = False
for njob, command in sorted(to_run.items()):
    expanded_command = Template(command).safe_substitute(environ)
    start = datetime.now()
    logging.info("Running job %d: `%s`", njob, expanded_command)
    try:
        result = check_output(expanded_command, stderr=STDOUT, shell=True, text=True)
        success = True
    except CalledProcessError as error:
        failed = True
        success = False
        result = str(error) + "\n" + error.output
        logging.exception("Failed!")
    end = datetime.now()
    log = [
        "",
        "===================================",
        "Job {}: `{}`".format(njob, expanded_command),
        "Started: {!s}".format(start),
        "Finished: {!s}".format(end),
        "Success: {!s}".format(success),
        "",
        result,
    ]
    logging.log(logging.INFO if success else logging.ERROR, "\n".join(log))
    message += log


# SMTP reporting
if all((smtp_host, smtp_port, from_, to, subject)):
    logging.info("Sending email report")
    smtp = None
    try:
        if smtp_tls:
            smtp = smtplib.SMTP_SSL(smtp_host, smtp_port)
        else:
            smtp = smtplib.SMTP(smtp_host, smtp_port)
        if smtp_user:
            smtp.ehlo()
            # If we can encrypt this session, do it
            if smtp.has_extn("STARTTLS"):
                smtp.starttls()
                smtp.ehlo()  # re-identify ourselves over TLS connection
            smtp.login(smtp_user, smtp_pass)
        message_text_obj = MIMEText("\r\n".join(message), "plain", "utf-8")
        message_text_obj["Subject"] = subject.format(
            hostname=getfqdn(),
            periodicity=periodicity,
            result="ERROR" if failed else "OK",
        )
        message_text_obj["From"] = from_
        message_text_obj["To"] = to
        message_text_obj["Date"] = formatdate()
        smtp.send_message(message_text_obj)
    except Exception:
        logging.exception("Failed sending email")
    finally:
        if smtp is not None:
            smtp.quit()

def rest_extract_dict(infix):
    d = {}
    for kname, kvalue in environ.items():
        match = re.match(f"^REST_{infix}_K_(.+)$", kname)
        if match:
            suffix = match.group(1)
            vname = f"REST_{infix}_V_{suffix}"
            rest_key = kvalue
            rest_value = environ.get(vname)
            if rest_value is None and infix == "PLD" and suffix == "MESSAGE":
                rest_value = "\n".join(message)
            if rest_key == "":
                logging.warning(f"{kname} empty, ignoring {suffix}")
                continue
            elif rest_value is None:
                logging.warning(f"{vname} unset but {kname} set, ignoring {suffix}")
                continue
            else:
                d[rest_key] = rest_value

    for vname, vvalue in environ.items():
        match = re.match(f"^REST_{infix}_V_(.+)$", vname)
        if match:
            suffix = match.group(1)
            kname = f"REST_{infix}_K_{suffix}"
            rest_key = environ.get(kname)
            if rest_key is None:
                logging.warning(f"{kname} unset but {vname} set, ignoring {suffix}")
                continue

    return d

# REST reporting
if all((rest_always or failed, rest_endpoint)):
    payload = rest_extract_dict("PLD")
    headers = rest_extract_dict("HDR")
    if rest_json:
        response = requests.post(rest_endpoint, json=payload, headers=headers)
    else:
        response = requests.post(rest_endpoint, data=payload, headers=headers)

logging.info("Finished")

if failed:
    sys.exit("At least one job failed")
